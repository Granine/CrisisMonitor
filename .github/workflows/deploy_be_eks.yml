name: Ephemeral EKS (no-model)

on:
  workflow_dispatch:
    inputs:
      keep_minutes:
        description: "Minutes to keep the cluster alive"
        default: "30"
        required: true
  # push:
  #   branches:
  #     - main
  #     - feat/model
  #   paths:
  #     - 'backend/**'
  #     - 'k8s/**'
  #     - '.github/workflows/deploy_be_eks.yml'

env:
  CLUSTER_NAME: mlapp-demo
  NAMESPACE: mlapp
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_URI: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_2 }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_2 }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl & eksctl
      shell: bash
      run: |
        set -euxo pipefail
        # Install kubectl
        K8S_VER=$(curl -L -s https://dl.k8s.io/release/stable.txt)
        curl -L -o kubectl "https://dl.k8s.io/release/${K8S_VER}/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/

        # Install eksctl
        EKSCTL_VER=$(curl -s https://api.github.com/repos/eksctl-io/eksctl/releases/latest | grep tag_name | cut -d '"' -f4 || echo "v0.215.0")
        echo "Installing eksctl version ${EKSCTL_VER}"
        curl -L "https://github.com/eksctl-io/eksctl/releases/download/${EKSCTL_VER}/eksctl_Linux_amd64.tar.gz" \
          -o /tmp/eksctl.tar.gz
        tar -xzf /tmp/eksctl.tar.gz -C /tmp || (echo "tar failed, check archive" && ls -lh /tmp && exit 1)
        sudo mv /tmp/eksctl /usr/local/bin/
        eksctl version
        kubectl version --client

    - name: Create EKS cluster (small + OIDC)
      run: |
        eksctl create cluster \
          --name "${CLUSTER_NAME}" \
          --region "${AWS_REGION}" \
          --nodes 1 \
          --node-type t3.small \
          --with-oidc \
          --timeout 30m

    - name: Install EBS CSI addon
      run: |
        eksctl create addon \
          --name aws-ebs-csi-driver \
          --cluster "${CLUSTER_NAME}" \
          --region "${AWS_REGION}" \
          --force

    - name: Create namespace
      run: |
        kubectl apply -f k8s/00-namespace.yaml
        kubectl get storageclass

    - name: Ensure gp3 storage class exists and is default
      shell: bash
      run: |
        # Check if gp3 already exists
        if ! kubectl get storageclass gp3 >/dev/null 2>&1; then
          echo "Creating gp3 storage class..."
          cat <<EOF | kubectl apply -f -
        apiVersion: storage.k8s.io/v1
        kind: StorageClass
        metadata:
          name: gp3
          annotations:
            storageclass.kubernetes.io/is-default-class: "true"
        provisioner: ebs.csi.aws.com
        volumeBindingMode: WaitForFirstConsumer
        allowVolumeExpansion: true
        parameters:
          type: gp3
          fsType: ext4
        EOF
        else
          echo "gp3 exists, marking as default..."
          kubectl annotate sc gp3 storageclass.kubernetes.io/is-default-class=true --overwrite
        fi

        echo "Available storage classes:"
        kubectl get storageclass

    - name: Log in to ECR
      run: |
        aws ecr get-login-password --region "${AWS_REGION}" \
          | docker login --username AWS --password-stdin "${ECR_URI}"

    - name: Ensure ECR repo for backend exists
      run: |
        aws ecr describe-repositories --repository-names "backend" >/dev/null 2>&1 \
        || aws ecr create-repository --repository-name "backend" >/dev/null

    - name: Build & push backend image (linux/amd64)
      run: |
        docker buildx create --use --name xbuilder || true
        docker buildx build --platform linux/amd64 -t "${ECR_URI}/backend:latest" ./backend --push

    - name: Patch image URI in backend manifest
      run: |
        sed -i "s~IMAGE_ECR_URI_BACKEND~${ECR_URI}/backend:latest~g" k8s/20-backend-deployment.yaml

    - name: Create ConfigMap
      run: kubectl apply -f k8s/01-configmap.yaml

    - name: Create Secret from GitHub secrets
      env:
        MONGO_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
        MONGO_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
      run: |
        enc_pw=$(python3 - <<'PY'
        import urllib.parse, os
        print(urllib.parse.quote(os.environ["MONGO_ROOT_PASSWORD"], safe=""))
        PY
        )
        MONGO_URI="mongodb://${MONGO_ROOT_USERNAME}:${enc_pw}@mongodb-0.mongodb-svc.${NAMESPACE}.svc.cluster.local:27017/?authSource=admin"

        kubectl -n "${NAMESPACE}" create secret generic app-secrets \
          --from-literal=MONGO_ROOT_USERNAME="${MONGO_ROOT_USERNAME}" \
          --from-literal=MONGO_ROOT_PASSWORD="${MONGO_ROOT_PASSWORD}" \
          --from-literal=MONGO_URI="${MONGO_URI}" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy MongoDB (StatefulSet + Service)
      run: |
        kubectl apply -n "${NAMESPACE}" -f k8s/30-mongodb-statefulset.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/31-mongodb-service.yaml
        kubectl -n "${NAMESPACE}" rollout status statefulset/mongodb --timeout=300s

    - name: Deploy backend only
      run: |
        kubectl apply -n "${NAMESPACE}" -f k8s/20-backend-deployment.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/21-backend-service.yaml


    - name: Wait and test backend
      shell: bash
      run: |
        set -euxo pipefail

        NAMESPACE="${NAMESPACE:-mlapp}"

        echo "Waiting for backend rollout..."
        kubectl -n "${NAMESPACE}" rollout status deploy/backend --timeout=350s

        POD=$(kubectl -n "${NAMESPACE}" get pods -l app=backend -o jsonpath='{.items[0].metadata.name}')
        echo "Using pod: $POD"

        CONTAINER_PORT=$(kubectl -n "${NAMESPACE}" get deploy backend -o jsonpath='{.spec.template.spec.containers[0].ports[0].containerPort}' 2>/dev/null || echo "")
        echo "Assumed container port: $CONTAINER_PORT"

        echo "--- pod describe ---"
        kubectl -n "${NAMESPACE}" describe pod "$POD" || true

        echo "--- pod logs (tail 200) ---"
        kubectl -n "${NAMESPACE}" logs "$POD" --tail=200 || true

        echo "--- listening sockets inside pod ---"
        kubectl -n "${NAMESPACE}" exec -it "$POD" -- sh -c 'ss -lntp || netstat -ltnp || echo "no ss/netstat available"' || true

        # Port-forward directly to the pod's container port (pods avoid svc targetPort surprises)
        kubectl -n "${NAMESPACE}" port-forward "pod/$POD" 8000:"${CONTAINER_PORT}" >/tmp/portforward.log 2>&1 &
        PF_PID=$!
        echo "started port-forward (pid=$PF_PID), sleeping 6s to let it come up..."
        sleep 6

        # show any port-forward output
        tail -n +1 /tmp/portforward.log || true

        # wait up to 15s for health endpoint to respond
        OK=0
        for i in $(seq 1 15); do
          if curl -fsS "http://localhost:8000/health" >/dev/null 2>&1; then
            OK=1
            break
          fi
          echo "waiting for forwarded port..."
          sleep 1
        done

        if [ "$OK" -ne 1 ]; then
          echo "Healthcheck failed after port-forward. Showing logs and describe..."
          kubectl -n "${NAMESPACE}" describe pod "$POD" || true
          kubectl -n "${NAMESPACE}" logs "$POD" --tail=400 || true
          echo "Port-forward log:"
          sed -n '1,200p' /tmp/portforward.log || true
          kill $PF_PID || true
          exit 1
        fi

        # example POST to backend predict endpoint (may return 503 if model endpoint not present)
        # curl -fsS -X POST "http://localhost:8000/predict-tweet" -H 'Content-Type: application/json' -d '{"text":"hello my house burned down!! help"}' || true

        kill $PF_PID || true

    - name: Demo window
      run: |
        KEEP=${{ github.event.inputs.keep_minutes || 30 }}
        echo "Cluster is up. Auto-cleanup in ${KEEP} minutes..."
        sleep $(( KEEP * 60 ))


    - name: Snapshot Mongo EBS volume (preserve data)
      if: always()
      run: |
        PVC="mongo-data-mongodb-0"
        PV=$(kubectl -n "${NAMESPACE}" get pvc "${PVC}" -o jsonpath='{.spec.volumeName}')
        VOL=$(kubectl get pv "${PV}" -o jsonpath='{.spec.csi.volumeHandle}')
        echo "Snapshotting EBS volume ${VOL} for ${PVC}"
        aws ec2 create-snapshot --volume-id "${VOL}" \
          --description "mlapp-mongo-snap-$(date +%F-%H%M%S)" >/dev/null
        echo "Snapshot requested."

    - name: Tear down cluster (stop all costs)
      if: always()
      run: eksctl delete cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}"
