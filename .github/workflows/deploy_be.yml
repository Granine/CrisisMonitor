name: Full EC2 Deployment (Auto-create + Deploy)

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/deploy_be.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  INSTANCE_NAME: disaster-classify-web
  IMAGE_NAME: viriyadhika/disaster-classification-mscac:latest
  SECURITY_GROUP: disaster-classify-sg
  KEY_NAME: disaster-keypair
  ROLE_NAME: EC2ParameterStoreAccessRole
  INSTANCE_PROFILE_NAME: EC2ParameterStoreProfile
  EBS_VOLUME_NAME: disaster-db-volume
  EBS_SIZE: 5  # GB

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # --- Create EC2 key pair ---
      - name: Create EC2 key pair (if missing)
        run: |
          if ! aws ec2 describe-key-pairs --key-names "${KEY_NAME}" >/dev/null 2>&1; then
            echo "Creating key pair..."
            aws ec2 create-key-pair --key-name "${KEY_NAME}" \
              --query "KeyMaterial" --output text > mykey.pem
            chmod 400 mykey.pem
          fi

      # --- Create Security Group ---
      - name: Create security group
        run: |
          if ! aws ec2 describe-security-groups --group-names "${SECURITY_GROUP}" >/dev/null 2>&1; then
            echo "Creating security group..."
            aws ec2 create-security-group \
              --group-name "${SECURITY_GROUP}" \
              --description "Allow SSH, HTTP, and MongoDB"
            aws ec2 authorize-security-group-ingress \
              --group-name "${SECURITY_GROUP}" \
              --protocol tcp --port 22 --cidr 0.0.0.0/0
            aws ec2 authorize-security-group-ingress \
              --group-name "${SECURITY_GROUP}" \
              --protocol tcp --port 80 --cidr 0.0.0.0/0
            aws ec2 authorize-security-group-ingress \
              --group-name "${SECURITY_GROUP}" \
              --protocol tcp --port 27017 --cidr 0.0.0.0/0
          fi

      # --- Ensure IAM Role for SSM access ---
      - name: Ensure IAM role and instance profile exist
        run: |
          set -e
          if ! aws iam get-role --role-name "${ROLE_NAME}" >/dev/null 2>&1; then
            aws iam create-role \
              --role-name "${ROLE_NAME}" \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [{"Effect": "Allow","Principal": {"Service": "ec2.amazonaws.com"},"Action": "sts:AssumeRole"}]
              }'
          fi

          aws iam put-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-name "ParameterStoreAccess" \
            --policy-document '{
              "Version": "2012-10-17",
              "Statement": [{"Effect": "Allow","Action": ["ssm:GetParameter","ssm:GetParameters","ssm:GetParametersByPath"],"Resource": "*"}]
            }'

          if ! aws iam get-instance-profile --instance-profile-name "${INSTANCE_PROFILE_NAME}" >/dev/null 2>&1; then
            aws iam create-instance-profile --instance-profile-name "${INSTANCE_PROFILE_NAME}"
            aws iam add-role-to-instance-profile \
              --instance-profile-name "${INSTANCE_PROFILE_NAME}" \
              --role-name "${ROLE_NAME}"
          fi

      # --- Launch EC2 instance with EBS volume ---
      - name: Launch EC2 instance and attach EBS
        id: launch
        run: |
          # Check if an instance already exists
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${INSTANCE_NAME}" \
            "Name=instance-state-name,Values=running,pending,stopped,stopping" \
            --query "Reservations[*].Instances[*].InstanceId" --output text)

          if [ -n "$INSTANCE_ID" ]; then
            echo "Existing instance found: $INSTANCE_ID"
            echo "Terminating existing instance..."
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" >/dev/null
            aws ec2 wait instance-terminated --instance-ids "$INSTANCE_ID"
            echo "Instance $INSTANCE_ID terminated."
          fi

          # Create new EC2 instance
          echo "Creating new EC2 instance..."
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-083b3f53cbda7e5a4 \
            --count 1 \
            --instance-type t3.micro \
            --key-name "${KEY_NAME}" \
            --user-data file://setup_be.sh \
            --iam-instance-profile Name="${INSTANCE_PROFILE_NAME}" \
            --security-groups "${SECURITY_GROUP}" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_NAME}}]" \
            --query "Instances[0].InstanceId" --output text)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

          echo "Waiting for instance to initialize..."
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

          # Detect which AZ the instance is in
          INSTANCE_AZ=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
            --query "Reservations[0].Instances[0].Placement.AvailabilityZone" --output text)
          echo "Instance is in AZ: $INSTANCE_AZ"

          # Check for existing EBS volume in same AZ
          VOLUME_ID=$(aws ec2 describe-volumes \
            --filters "Name=tag:Name,Values=${EBS_VOLUME_NAME}" "Name=availability-zone,Values=${INSTANCE_AZ}" \
            --query "Volumes[0].VolumeId" --output text)

          if [ "$VOLUME_ID" = "None" ] || [ -z "$VOLUME_ID" ]; then
            echo "No existing volume found. Creating a new one in ${INSTANCE_AZ}..."
            VOLUME_ID=$(aws ec2 create-volume \
              --availability-zone ${INSTANCE_AZ} \
              --size ${EBS_SIZE} \
              --volume-type gp3 \
              --tag-specifications "ResourceType=volume,Tags=[{Key=Name,Value=${EBS_VOLUME_NAME}}]" \
              --query "VolumeId" --output text)
            aws ec2 wait volume-available --volume-ids $VOLUME_ID
          else
            echo "Reusing existing volume: $VOLUME_ID"
          fi

          # Attach the EBS volume to the instance
          echo "Attaching volume..."
          aws ec2 attach-volume --device /dev/xvdf --instance-id $INSTANCE_ID --volume-id $VOLUME_ID

          echo "VOLUME_ID=$VOLUME_ID" >> $GITHUB_ENV

      # --- Get Public IP ---
      - name: Get public IP
        id: ec2ip
        run: |
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "Instance Public IP: $PUBLIC_IP"

      - name: Output final status
        run: echo "âœ… Backend + MongoDB deployed and reachable at http://${{ env.PUBLIC_IP }}"
