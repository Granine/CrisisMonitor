name: Full EC2 Deployment (Auto-create + Deploy)

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'      # only trigger when something inside frontend changes
      - '.github/workflows/deploy_be.yml' # (optional) trigger if workflow itself changes
  workflow_dispatch:        # allows manual runs too

env:
  AWS_REGION: us-east-2
  INSTANCE_NAME: disaster-classify-web
  IMAGE_NAME: viriyadhika/disaster-classification-mscac:latest
  SECURITY_GROUP: disaster-classify-sg
  KEY_NAME: disaster-keypair
  ROLE_NAME: EC2ParameterStoreAccessRole
  INSTANCE_PROFILE_NAME: EC2ParameterStoreProfile

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # --- Create Key Pair if not exists ---
      - name: Create EC2 key pair (if missing)
        run: |
          if ! aws ec2 describe-key-pairs --key-names "${KEY_NAME}" >/dev/null 2>&1; then
            echo "Creating key pair..."
            aws ec2 create-key-pair --key-name "${KEY_NAME}" \
              --query "KeyMaterial" --output text > mykey.pem
            chmod 400 mykey.pem
          else
            echo "Key pair already exists."
          fi

      # --- Create Security Group if not exists ---
      - name: Create security group
        run: |
          if ! aws ec2 describe-security-groups --group-names "${SECURITY_GROUP}" >/dev/null 2>&1; then
            echo "Creating security group..."
            aws ec2 create-security-group \
              --group-name "${SECURITY_GROUP}" \
              --description "Allow SSH and HTTP"
            aws ec2 authorize-security-group-ingress \
              --group-name "${SECURITY_GROUP}" \
              --protocol tcp --port 22 --cidr 0.0.0.0/0
            aws ec2 authorize-security-group-ingress \
              --group-name "${SECURITY_GROUP}" \
              --protocol tcp --port 80 --cidr 0.0.0.0/0
          else
            echo "Security group already exists."
          fi

      # --- Launch EC2 instance (if none exist) ---
      # --- Create IAM Role for EC2 access to Parameter Store ---
      - name: Ensure IAM role and instance profile exist
        run: |
          set -e

          # Create IAM Role if missing
          if ! aws iam get-role --role-name "${ROLE_NAME}" >/dev/null 2>&1; then
            echo "Creating IAM role: ${ROLE_NAME}"
            aws iam create-role \
              --role-name "${ROLE_NAME}" \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": { "Service": "ec2.amazonaws.com" },
                    "Action": "sts:AssumeRole"
                  }
                ]
              }'
          else
            echo "IAM role already exists: ${ROLE_NAME}"
          fi

          # Attach inline policy for SSM access
          aws iam put-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-name "ParameterStoreAccess" \
            --policy-document '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "ssm:GetParameter",
                    "ssm:GetParameters",
                    "ssm:GetParametersByPath"
                  ],
                  "Resource": "*"
                }
              ]
            }'

          # Create instance profile if missing
          if ! aws iam get-instance-profile --instance-profile-name "${INSTANCE_PROFILE_NAME}" >/dev/null 2>&1; then
            echo "Creating instance profile: ${INSTANCE_PROFILE_NAME}"
            aws iam create-instance-profile --instance-profile-name "${INSTANCE_PROFILE_NAME}"
            aws iam add-role-to-instance-profile \
              --instance-profile-name "${INSTANCE_PROFILE_NAME}" \
              --role-name "${ROLE_NAME}"
          else
            echo "Instance profile already exists: ${INSTANCE_PROFILE_NAME}"
          fi

      # --- Launch EC2 instance (if none exist) ---
      - name: Launch EC2 instance
        id: launch
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=running,pending,stopped,stopping" \
            --query "Reservations[*].Instances[*].InstanceId" --output text)

          if [ -n "$INSTANCE_ID" ]; then
            echo "Existing instance found: $INSTANCE_ID"
            echo "Terminating existing instance..."
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" >/dev/null
            echo "Waiting for instance to terminate..."
            aws ec2 wait instance-terminated --instance-ids "$INSTANCE_ID"
            echo "Instance $INSTANCE_ID terminated."
          fi

          echo "Creating new EC2 instance..."
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0cfde0ea8edd312d4 \
            --count 1 \
            --instance-type t3.micro \
            --key-name "${KEY_NAME}" \
            --user-data file://setup_be.sh \
            --iam-instance-profile Name="${INSTANCE_PROFILE_NAME}" \
            --security-groups "${SECURITY_GROUP}" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_NAME}}]" \
            --query "Instances[0].InstanceId" --output text)

          echo "New instance created: $INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV


      # --- Wait for instance and get its public IP ---
      - name: Wait for EC2 and get public IP
        id: ec2ip
        run: |
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "Instance Public IP: $PUBLIC_IP"

      - name: Output final status
        run: echo "âœ… App is deployed and reachable at http://${{ env.PUBLIC_IP }}"
