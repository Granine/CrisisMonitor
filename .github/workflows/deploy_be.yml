name: Ephemeral EKS

on:
  workflow_dispatch:
    inputs:
      keep_minutes:
        description: "Minutes to keep the cluster alive"
        default: "30"
        required: true
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'model/**'
      - 'k8s/**'
      - '.github/workflows/deploy_be.yml'

env:
  CLUSTER_NAME: mlapp-demo
  NAMESPACE: mlapp
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_URI: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com


jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
    - name: Checkout
      uses: actions/checkout@v4


    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl & eksctl
      shell: bash
      run: |
        # Install kubectl
        K8S_VER=$(curl -L -s https://dl.k8s.io/release/stable.txt)
        curl -L -o kubectl "https://dl.k8s.io/release/${K8S_VER}/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/

        # Install eksctl (use stable release, not "latest")
        EKSCTL_VER=$(curl -s https://api.github.com/repos/eksctl-io/eksctl/releases/latest | grep tag_name | cut -d '"' -f4)
        curl -L "https://github.com/eksctl-io/eksctl/releases/download/${EKSCTL_VER}/eksctl_Linux_amd64.tar.gz" \
          -o /tmp/eksctl.tar.gz
        tar -xzf /tmp/eksctl.tar.gz -C /tmp
        sudo mv /tmp/eksctl /usr/local/bin/
        eksctl version
        kubectl version --client


    - name: Create EKS cluster (small + OIDC)
      run: |
        eksctl create cluster \
          --name "${CLUSTER_NAME}" \
          --region "${AWS_REGION}" \
          --nodes 1 \
          --node-type t3.small \
          --with-oidc \
          --timeout 30m

    - name: Install EBS CSI addon
      run: |
        eksctl create addon \
          --name aws-ebs-csi-driver \
          --cluster "${CLUSTER_NAME}" \
          --region "${AWS_REGION}" \
          --force

    - name: Create namespace
      run: |
        kubectl apply -f k8s/00-namespace.yaml
        kubectl get storageclass



    - name: Ensure gp3 storage class exists and is default
      shell: bash
      run: |
        # Check if gp3 already exists
        if ! kubectl get storageclass gp3 >/dev/null 2>&1; then
          echo "Creating gp3 storage class..."
          cat <<EOF | kubectl apply -f -
        apiVersion: storage.k8s.io/v1
        kind: StorageClass
        metadata:
          name: gp3
          annotations:
            storageclass.kubernetes.io/is-default-class: "true"
        provisioner: ebs.csi.aws.com
        volumeBindingMode: WaitForFirstConsumer
        allowVolumeExpansion: true
        parameters:
          type: gp3
          fsType: ext4
        EOF
        else
          echo "gp3 exists, marking as default..."
          kubectl annotate sc gp3 storageclass.kubernetes.io/is-default-class=true --overwrite
        fi

        echo "Available storage classes:"
        kubectl get storageclass


    - name: Log in to ECR
      run: |
        aws ecr get-login-password --region "${AWS_REGION}" \
          | docker login --username AWS --password-stdin "${ECR_URI}"

    - name: Ensure ECR repos exist
      run: |
        for repo in backend model; do
          aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "$repo" >/dev/null
        done

    - name: Build & push images (linux/amd64)
      run: |
        docker buildx create --use --name xbuilder || true
        docker buildx build --platform linux/amd64 -t "${ECR_URI}/backend:latest" ./backend --push
        docker buildx build --platform linux/amd64 -t "${ECR_URI}/model:latest"   ./model   --push

    - name: Patch image URIs in manifests
      run: |
        sed -i "s~IMAGE_ECR_URI_MODEL~${ECR_URI}/model:latest~g" k8s/10-model-deployment.yaml
        sed -i "s~IMAGE_ECR_URI_BACKEND~${ECR_URI}/backend:latest~g" k8s/20-backend-deployment.yaml

    - name: Create ConfigMap
      run: kubectl apply -f k8s/01-configmap.yaml

    - name: Create Secret from GitHub secrets
      env:
        MONGO_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
        MONGO_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
      run: |
        enc_pw=$(python3 - <<'PY'
        import urllib.parse, os
        print(urllib.parse.quote(os.environ["MONGO_ROOT_PASSWORD"], safe=""))
        PY
        )
        MONGO_URI="mongodb://${MONGO_ROOT_USERNAME}:${enc_pw}@mongodb-0.mongodb-svc.${NAMESPACE}.svc.cluster.local:27017/?authSource=admin"

        kubectl -n "${NAMESPACE}" create secret generic app-secrets \
          --from-literal=MONGO_ROOT_USERNAME="${MONGO_ROOT_USERNAME}" \
          --from-literal=MONGO_ROOT_PASSWORD="${MONGO_ROOT_PASSWORD}" \
          --from-literal=MONGO_URI="${MONGO_URI}" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy MongoDB (StatefulSet + Service)
      run: |
        kubectl apply -n "${NAMESPACE}" -f k8s/30-mongodb-statefulset.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/31-mongodb-service.yaml
        kubectl -n "${NAMESPACE}" rollout status statefulset/mongodb --timeout=300s

    - name: Deploy model + backend
      run: |
        kubectl apply -n "${NAMESPACE}" -f k8s/10-model-deployment.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/11-model-service.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/20-backend-deployment.yaml
        kubectl apply -n "${NAMESPACE}" -f k8s/21-backend-service.yaml

    - name: Wait and test
      run: |
        kubectl -n "${NAMESPACE}" rollout status deploy/model   --timeout=650s
        kubectl -n "${NAMESPACE}" rollout status deploy/backend --timeout=350s
        kubectl -n "${NAMESPACE}" port-forward svc/backend-svc 8000:80 &
        PF_PID=$!
        sleep 8
        curl -fsS http://localhost:8000/health
        curl -fsS -X POST http://localhost:8000/classify -H 'Content-Type: application/json' -d '{"text":"hello my house burned down!! help"}' || true
        kill $PF_PID || true


    - name: Demo window
      run: |
        echo "Cluster is up. Auto-cleanup in ${{ github.event.inputs.keep_minutes || 30 }} minutes..."
        sleep "$(( ${{ github.event.inputs.keep_minutes }} * 60 ))"

    - name: Snapshot Mongo EBS volume (preserve data)
      if: always()
      run: |
        PVC="mongo-data-mongodb-0"
        PV=$(kubectl -n "${NAMESPACE}" get pvc "${PVC}" -o jsonpath='{.spec.volumeName}')
        VOL=$(kubectl get pv "${PV}" -o jsonpath='{.spec.csi.volumeHandle}')
        echo "Snapshotting EBS volume ${VOL} for ${PVC}"
        aws ec2 create-snapshot --volume-id "${VOL}" \
          --description "mlapp-mongo-snap-$(date +%F-%H%M%S)" >/dev/null
        echo "Snapshot requested."

    - name: Tear down cluster (stop all costs)
      if: always()
      run: eksctl delete cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}"
